class my_class:
    def __init__(self, titel_lesson, body, code, img, next_anw, btn_lst, btn_nxt, index):
        self.titel_lesson = titel_lesson
        self.body = body
        self.code = code
        self.img = img
        self.next_anw = next_anw
        self.btn_lst = btn_lst
        self.btn_nxt = btn_nxt
        self.index = index


lektion1 = my_class( "Lektion 1: Was ist Linux?", 
""" Linux ist ein freies und quelloffenes Betriebssystem, das 1991 von Linus Torvalds entwickelt wurde. Anders als Windows oder macOS ist Linux kostenlos und kann von jedem verwendet, modifiziert und verteilt werden. Linux basiert auf Unix und verwendet einen Kernel (Betriebssystemkern), der die Hardware verwaltet. Auf diesem Kernel bauen verschiedene Distributionen auf: Ubuntu, Debian, CentOS, Fedora, openSUSE und viele mehr. Jede Distribution hat ihre eigenen Besonderheiten, aber alle verwenden denselben Linux-Kernel. Linux läuft auf fast allen Geräten: von Smartphones (Android basiert auf Linux) über Desktop-Computer bis hin zu Supercomputern und Servern. Über 90% aller Webserver laufen auf Linux! Das Dateisystem in Linux ist hierarchisch aufgebaut und beginnt mit dem Root-Verzeichnis (/). Wichtige Verzeichnisse sind: /home (Benutzerverzeichnisse), /etc (Konfigurationsdateien), /var (variable Daten), /usr (Benutzerprogramme), /bin (grundlegende Programme). Linux unterscheidet zwischen Groß- und Kleinschreibung - 'Datei.txt' und 'datei.txt' sind verschiedene Dateien! In diesem ersten Beispiel siehst du grundlegende Linux-Befehle zum Navigieren im Dateisystem. """,
"""# Grundlegende Linux-Navigation ls # Zeigt Dateien und Verzeichnisse an ls -l # Detaillierte Ansicht mit Berechtigungen ls -la # Auch versteckte Dateien anzeigen pwd # Zeigt aktuelles Verzeichnis an cd /home # Wechselt in das /home Verzeichnis cd ~ # Wechselt ins eigene Benutzerverzeichnis cd .. # Wechselt ein Verzeichnis nach oben cd - # Wechselt zum vorherigen Verzeichnis whoami # Zeigt aktuellen Benutzernamen an date # Zeigt Datum und Uhrzeit an uname -a # Zeigt Systeminformationen an""", 
"linux1.png", 
"In der nächsten Lektion lernst du Dateien und Verzeichnisse zu verwalten.", 
"Zurück zur Startseite", 
"Weiter zu Lektion 2",
 1 )

lektion2 = my_class( "Lektion 2: Dateien und Verzeichnisse verwalten", 
""" Die Verwaltung von Dateien und Verzeichnissen ist eine der wichtigsten Fähigkeiten in Linux. Linux bietet mächtige Kommandozeilen-Tools, die oft effizienter sind als grafische Oberflächen. Zum Erstellen von Dateien verwendest du 'touch' für leere Dateien oder Editoren wie 'nano', 'vim' oder 'gedit'. Verzeichnisse erstellst du mit 'mkdir', und mit der Option '-p' kannst du sogar ganze Verzeichnisstrukturen auf einmal erstellen. Zum Kopieren verwendest du 'cp' für Dateien und 'cp -r' für Verzeichnisse rekursiv. Das Verschieben und Umbenennen funktioniert mit 'mv' - ein Befehl für beide Operationen! Zum Löschen verwendest du 'rm' für Dateien und 'rm -r' für Verzeichnisse. Sei vorsichtig: In Linux gibt es keinen Papierkorb auf der Kommandozeile! Wildcards sind sehr nützlich: '*' steht für beliebige Zeichen, '?' für ein einzelnes Zeichen, und '[abc]' für eines der angegebenen Zeichen. Dateiberechtigungen sind in Linux sehr wichtig und werden durch drei Zahlen dargestellt: Besitzer, Gruppe, und alle anderen. Jede Zahl ist die Summe aus: 4 (Lesen), 2 (Schreiben), 1 (Ausführen). """, 
"""# Dateien und Verzeichnisse erstellen touch neue_datei.txt # Leere Datei erstellen mkdir neues_verzeichnis # Verzeichnis erstellen mkdir -p pfad/zu/neuem/verzeichnis # Verschachtelte Verzeichnisse echo "Hallo Linux" > datei.txt # Text in Datei schreiben # Kopieren und Verschieben cp datei.txt kopie.txt # Datei kopieren cp -r verzeichnis verzeichnis_kopie # Verzeichnis rekursiv kopieren mv alte_datei.txt neue_datei.txt # Datei umbenennen mv datei.txt /home/user/ # Datei verschieben # Löschen rm datei.txt # Datei löschen rm -r verzeichnis # Verzeichnis rekursiv löschen rm -rf verzeichnis # Forciert löschen (gefährlich!) # Wildcards verwenden ls *.txt # Alle .txt Dateien anzeigen cp *.pdf /backup/ # Alle PDF-Dateien kopieren # Dateiberechtigungen ändern chmod 755 script.sh # Ausführbar für Besitzer, lesbar für alle chmod -R 644 verzeichnis/ # Rekursiv auf Verzeichnis anwenden""", 
"linux2.png", 
"In der nächsten Lektion lernst du Textdateien zu bearbeiten und zu durchsuchen.", 
"Zurück zu Lektion 1", 
"Weiter zu Lektion 3",
 2 )

lektion3 = my_class( "Lektion 3: Textbearbeitung und Suche", 
""" Linux bietet mächtige Werkzeuge für die Textverarbeitung. Diese Tools sind besonders nützlich für die Analyse von Logdateien, Konfigurationsdateien und Datenverarbeitung. 'cat' zeigt Dateiinhalt an, 'less' und 'more' ermöglichen seitenweise Anzeige großer Dateien. Mit 'head' siehst du die ersten Zeilen, mit 'tail' die letzten - 'tail -f' verfolgt sogar Änderungen in Echtzeit! 'grep' ist das wichtigste Suchwerkzeug in Linux. Es sucht nach Textmustern in Dateien und unterstützt reguläre Ausdrücke. Mit Optionen wie '-i' (ignoriert Groß-/Kleinschreibung), '-r' (rekursiv), '-n' (mit Zeilennummern) wird es noch mächtiger. 'find' sucht Dateien nach verschiedenen Kriterien: Name, Größe, Datum, Berechtigungen. Es kann auch Aktionen auf gefundene Dateien ausführen. Pipes (|) sind ein mächtiges Konzept in Linux: Die Ausgabe eines Befehls wird zur Eingabe des nächsten. So kannst du komplexe Datenverarbeitungsketten erstellen. 'sort' sortiert Zeilen, 'uniq' entfernt Duplikate, 'wc' zählt Wörter/Zeilen/Zeichen, und 'cut' extrahiert bestimmte Spalten aus Text. """, 
"""# Dateiinhalt anzeigen cat datei.txt # Gesamten Inhalt anzeigen less datei.txt # Seitenweise anzeigen (q zum Beenden) head -n 10 datei.txt # Erste 10 Zeilen anzeigen tail -n 5 datei.txt # Letzte 5 Zeilen anzeigen tail -f logfile.log # Datei in Echtzeit verfolgen # Text suchen mit grep grep "fehler" logfile.log # Nach "fehler" suchen grep -i "ERROR" *.log # Groß-/Kleinschreibung ignorieren grep -r "TODO" . # Rekursiv in allen Dateien suchen grep -n "function" script.py # Mit Zeilennummern anzeigen # Dateien finden find /home -name "*.txt" # Alle .txt Dateien finden find . -size +1M # Dateien größer als 1MB find /var/log -mtime -7 # In letzten 7 Tagen geändert find . -type f -exec chmod 644 {} \; # Aktion auf gefundene Dateien # Pipes und Textverarbeitung cat datei.txt | grep "wichtig" | sort # Suchen und sortieren ps aux | grep python | wc -l # Python-Prozesse zählen ls -la | sort -k5 -n # Nach Dateigröße sortieren cut -d':' -f1 /etc/passwd | sort # Benutzernamen extrahieren history | tail -20 | grep cd # Letzte cd-Befehle finden""", 
"linux3.png", 
"In der nächsten Lektion lernst du Prozess- und Systemverwaltung.", 
"Zurück zu Lektion 2", 
"Weiter zu Lektion 4",
 3 )

lektion4 = my_class( "Lektion 4: Prozess- und Systemverwaltung", 
""" Prozessverwaltung ist ein zentraler Aspekt der Linux-Systemadministration. Jedes laufende Programm ist ein Prozess mit einer eindeutigen Prozess-ID (PID). 'ps' zeigt laufende Prozesse an. Mit 'ps aux' erhältst du eine detaillierte Übersicht aller Prozesse im System. 'top' und 'htop' zeigen Prozesse in Echtzeit mit CPU- und Speicherverbrauch. Mit 'kill' kannst du Prozesse beenden. 'kill -9 PID' beendet einen Prozess forciert, während 'killall prozessname' alle Prozesse mit diesem Namen beendet. Jobs können im Hintergrund laufen: Füge '&' am Ende eines Befehls hinzu. Mit 'jobs' siehst du Hintergrundjobs, 'fg' bringt sie in den Vordergrund. Systemressourcen überwachst du mit 'free' (Speicher), 'df' (Festplattenspeicher), 'du' (Verzeichnisgrößen), und 'uptime' (Systemlaufzeit und Load). Services (Dienste) verwaltest du mit 'systemctl' bei systemd-basierten Distributionen. Du kannst Services starten, stoppen, neu starten und ihren Status überprüfen. Umgebungsvariablen speichern wichtige Systeminformationen. 'env' zeigt alle an, mit 'export' setzt du neue. Die PATH-Variable bestimmt, wo Linux nach ausführbaren Dateien sucht. """, 
"""# Prozesse anzeigen und verwalten ps aux # Alle laufenden Prozesse anzeigen ps -ef | grep apache # Nach Apache-Prozessen suchen top # Interaktive Prozessanzeige (q zum Beenden) htop # Verbesserte Version von top (falls installiert) # Prozesse beenden kill 1234 # Prozess mit PID 1234 beenden kill -9 1234 # Prozess forciert beenden (SIGKILL) killall firefox # Alle Firefox-Prozesse beenden pkill -f "python script.py" # Prozesse nach Befehlszeile beenden # Hintergrundjobs python script.py & # Skript im Hintergrund starten jobs # Aktuelle Hintergrundjobs anzeigen fg %1 # Job Nummer 1 in Vordergrund bringen bg %2 # Job Nummer 2 im Hintergrund weiterführen nohup long_running_script.sh & # Prozess läuft auch nach Logout weiter # Systemressourcen überwachen free -h # Speicherverbrauch (human readable) df -h # Festplattenspeicher anzeigen du -sh /var/log # Verzeichnisgröße anzeigen uptime # Systemlaufzeit und Load anzeigen iostat # I/O-Statistiken (falls installiert) # Services verwalten (systemd) systemctl status apache2 # Service-Status prüfen systemctl start apache2 # Service starten systemctl stop apache2 # Service stoppen systemctl restart apache2 # Service neu starten systemctl enable apache2 # Service beim Boot aktivieren # Umgebungsvariablen env # Alle Umgebungsvariablen anzeigen echo $PATH # PATH-Variable anzeigen export MYVAR="Hallo Welt" # Neue Variable setzen""", 
"linux4.png", 
"In der nächsten Lektion lernst du Netzwerk-Grundlagen in Linux.", 
"Zurück zu Lektion 3", 
"Weiter zu Lektion 5",
 4 )

lektion5 = my_class( "Lektion 5: Netzwerk-Grundlagen", 
""" Linux bietet umfassende Netzwerk-Tools für Diagnose, Konfiguration und Überwachung. Diese Fähigkeiten sind essentiell für Systemadministratoren und Entwickler. 'ping' testet die Erreichbarkeit von Hosts und misst die Latenz. 'traceroute' zeigt den Weg, den Pakete durch das Netzwerk nehmen. 'netstat' und das modernere 'ss' zeigen Netzwerkverbindungen und offene Ports an. 'wget' und 'curl' laden Dateien aus dem Internet herunter. Curl ist besonders mächtig für API-Tests und kann verschiedene HTTP-Methoden verwenden. SSH (Secure Shell) ist das wichtigste Tool für Remote-Administration. Mit 'ssh user@server' verbindest du dich zu entfernten Systemen. 'scp' kopiert Dateien über SSH, 'rsync' synchronisiert Verzeichnisse effizient. Firewalls schützen dein System vor unerwünschtem Netzwerkverkehr. 'ufw' (Uncomplicated Firewall) ist ein benutzerfreundliches Frontend für iptables. Du kannst Ports öffnen, schließen und Regeln definieren. Netzwerkkonfiguration erfolgt oft über '/etc/network/interfaces' oder mit modernen Tools wie 'nmcli' (NetworkManager). DNS-Auflösung konfigurierst du in '/etc/resolv.conf'. 'dig' und 'nslookup' helfen bei DNS-Problemen. """, 
"""# Netzwerk-Diagnose ping google.com # Host erreichbarkeit testen ping -c 4 192.168.1.1 # Nur 4 Pings senden traceroute google.com # Route zu Host verfolgen mtr google.com # Kombiniert ping und traceroute # Netzwerkverbindungen anzeigen netstat -tuln # TCP/UDP Listening Ports ss -tuln # Moderner Ersatz für netstat netstat -an | grep :80 # Wer hört auf Port 80 lsof -i :22 # Welcher Prozess nutzt Port 22 # Dateien herunterladen wget https://example.com/datei.zip # Datei herunterladen curl -O https://example.com/datei.zip # Mit curl herunterladen curl -X POST -d "key=value" http://api.example.com # API-Request curl -I https://example.com # Nur HTTP-Header anzeigen # SSH und Remote-Zugriff ssh user@192.168.1.100 # SSH-Verbindung aufbauen ssh -p 2222 user@server # Anderer Port als 22 scp datei.txt user@server:/home/user/ # Datei kopieren rsync -avz /local/dir/ user@server:/remote/dir/ # Verzeichnis synchronisieren # Firewall mit ufw ufw status # Firewall-Status anzeigen ufw enable # Firewall aktivieren ufw allow 22 # SSH-Port öffnen ufw allow from 192.168.1.0/24 # Nur bestimmtes Netzwerk ufw deny 80 # Port blockieren # DNS und Netzwerk-Tools dig google.com # DNS-Auflösung testen nslookup google.com # Alternative zu dig host google.com # Einfache DNS-Abfrage whois example.com # Domain-Informationen abfragen ifconfig # Netzwerkinterfaces anzeigen (veraltet) ip addr show # Moderne Alternative zu ifconfig""", 
"linux5.png", 
"In der letzten Lektion lernst du Skripting und Automatisierung.", 
"Zurück zu Lektion 4", 
"Weiter zu Lektion 6",
 5 )

lektion6 = my_class( "Lektion 6: Skripting und Automatisierung", 
""" Shell-Scripting ist eine der mächtigsten Fähigkeiten in Linux und ermöglicht die Automatisierung wiederkehrender Aufgaben. Bash (Bourne Again Shell) ist die Standard-Shell in den meisten Linux-Distributionen. Shell-Skripte beginnen mit der Shebang-Zeile (#!/bin/bash), die dem System mitteilt, welche Shell verwendet werden soll. Variablen in Bash werden ohne '$' definiert und mit '$' aufgerufen. Verwende Anführungszeichen um Leerzeichen zu behandeln. Kontrollstrukturen wie if-then-else, for-Schleifen und while-Schleifen ermöglichen komplexe Logik. Funktionen organisieren Code und machen ihn wiederverwendbar. Cron ist der Task-Scheduler von Linux. Mit 'crontab -e' bearbeitest du deine Cron-Jobs. Die Syntax folgt dem Format: Minute Stunde Tag Monat Wochentag Befehl. Beispiel: '0 2 * * *' führt täglich um 2 Uhr aus. Fehlerbehandlung ist wichtig: Überprüfe Exit-Codes mit '$?' und verwende 'set -e' um bei Fehlern zu stoppen. Logging hilft bei der Fehlersuche - leite Ausgaben in Dateien um. Parameter an Skripte übergibst du über '$1', '$2', etc. '$0' ist der Skriptname, '$#' die Anzahl Parameter, '$@' alle Parameter. Mit 'chmod +x script.sh' machst du Skripte ausführbar. """, 
"""#!/bin/bash # Backup-Skript Beispiel - Speichere als backup.sh # Variablen definieren SOURCE_DIR="/home/user/documents" BACKUP_DIR="/backup/$(date +%Y%m%d)" LOG_FILE="/var/log/backup.log" # Funktion für Logging log_message() { echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE } # Backup-Verzeichnis erstellen if [ ! -d "$BACKUP_DIR" ]; then mkdir -p "$BACKUP_DIR" log_message "Backup-Verzeichnis erstellt: $BACKUP_DIR" fi # Backup durchführen log_message "Backup gestartet von $SOURCE_DIR nach $BACKUP_DIR" if rsync -av "$SOURCE_DIR/" "$BACKUP_DIR/"; then log_message "Backup erfolgreich abgeschlossen" echo "Backup erfolgreich!" else log_message "FEHLER: Backup fehlgeschlagen" echo "Backup fehlgeschlagen!" >&2 exit 1 fi # Alte Backups löschen (älter als 30 Tage) find /backup -type d -name "20*" -mtime +30 -exec rm -rf {} + 2>/dev/null log_message "Alte Backups bereinigt" # Beispiel Crontab-Einträge (mit 'crontab -e' hinzufügen): # 0 2 * * * /home/user/backup.sh # Täglich um 2 Uhr # */15 * * * * /usr/bin/system_check.sh # Alle 15 Minuten # 0 0 * * 0 /home/user/weekly_cleanup.sh # Sonntags um Mitternacht # Erweiterte Bash-Features for file in *.log; do echo "Verarbeite: $file" gzip "$file" # Komprimieren done # Parameter verarbeiten if [ $# -eq 0 ]; then echo "Verwendung: $0 <Quellverzeichnis>" exit 1 fi echo "Skript: $0 wurde mit $# Parametern aufgerufen" echo "Alle Parameter: $@" """,
"linux6.png", 
"Herzlichen Glückwunsch! Du hast alle Linux-Grundlagen gemeistert.", 
"Zurück zu Lektion 5", 
"Kurs abgeschlossen", 
6 )

linux_list = [lektion1, lektion2, lektion3, lektion4, lektion5, lektion6]