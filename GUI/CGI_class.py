class my_class:
    def __init__(self, titel_lesson, body, code, img, next_anw, btn_lst, btn_nxt, index):
        self.titel_lesson = titel_lesson
        self.body = body
        self.code = code
        self.img = img
        self.next_anw = next_anw
        self.btn_lst = btn_lst
        self.btn_nxt = btn_nxt
        self.index = index



lektion1 = my_class( "Lektion 1: Was ist CGI?",
""" CGI steht für Common Gateway Interface und ist eine Technologie, die es ermöglicht, dynamische Webseiten zu erstellen. CGI wurde in den frühen 1990er Jahren entwickelt und war eine der ersten Methoden, um interaktive Websites zu schaffen. CGI-Skripte laufen auf dem Webserver und können in verschiedenen Programmiersprachen geschrieben werden: Perl, Python, C, Shell-Scripts oder sogar JavaScript mit Node.js. Wenn ein Benutzer eine Webseite aufruft, die ein CGI-Skript verwendet, startet der Webserver das Skript als separaten Prozess. Das Skript verarbeitet die Anfrage, generiert HTML-Code und sendet diesen zurück an den Browser des Benutzers. CGI-Skripte werden häufig für Kontaktformulare, Gästebücher, Suchfunktionen und Datenbankanwendungen verwendet. Der Webserver kommuniziert mit CGI-Skripten über Umgebungsvariablen und Standardein-/ausgabe. In diesem ersten Beispiel siehst du ein einfaches CGI-Skript in Perl, das eine Grundstruktur zeigt. Der Content-Type-Header teilt dem Browser mit, dass HTML-Inhalt folgt. Die doppelte Leerzeile nach dem Header ist wichtig - sie trennt die HTTP-Header vom eigentlichen Inhalt. """,
"""#!/usr/bin/perl # Einfaches CGI-Skript in Perl print &#x22;Content-Type: text/html\n\n&#x22;; # HTTP-Header print &#x22;&#x3C;html&#x3E;\n&#x22;; print &#x22;&#x3C;head&#x3E;&#x3C;title&#x3E;Mein erstes CGI-Skript&#x3C;/title&#x3E;&#x3C;/head&#x3E;\n&#x22;; print &#x22;&#x3C;body&#x3E;\n&#x22;; print &#x22;&#x3C;h1&#x3E;Willkommen bei CGI!&#x3C;/h1&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;Dieses ist mein erstes CGI-Skript.&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;Aktuelle Zeit: &#x22; . localtime() . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;/body&#x3E;\n&#x22;; print &#x22;&#x3C;/html&#x3E;\n&#x22;;""",
"cgi1.png",
"In der nächsten Lektion lernst du, wie du Formulardaten verarbeitest.",
"Zurück zur Startseite", 
"Weiter zu Lektion 2",
1 )

lektion2 = my_class( "Lektion 2: Formulardaten verarbeiten", 
""" Eine der häufigsten Anwendungen von CGI ist die Verarbeitung von HTML-Formularen. Wenn ein Benutzer ein Formular absendet, werden die Daten an das CGI-Skript übertragen. Es gibt zwei Hauptmethoden für die Datenübertragung: GET und POST. Bei der GET-Methode werden die Daten in der URL übertragen und sind in der Umgebungsvariable QUERY_STRING verfügbar. Bei der POST-Methode werden die Daten über die Standardeingabe (STDIN) übertragen und sind nicht in der URL sichtbar. Formulardaten werden URL-kodiert übertragen, das bedeutet, Leerzeichen werden zu '+' und Sonderzeichen werden als %XX kodiert. CGI-Skripte müssen diese Kodierung rückgängig machen (URL-Dekodierung). Die Daten kommen im Format 'name1=wert1&name2=wert2' an. Jedes name=wert-Paar entspricht einem Formularfeld. In diesem Beispiel zeige ich dir ein CGI-Skript, das Formulardaten verarbeitet. Das Skript prüft zuerst die REQUEST_METHOD um zu unterscheiden zwischen GET und POST. Dann werden die Daten entsprechend ausgelesen und verarbeitet. Die URI::Escape-Bibliothek hilft bei der URL-Dekodierung. """, 
"""#!/usr/bin/perl use strict; use warnings; use URI::Escape; print &#x22;Content-Type: text/html\n\n&#x22;; # Formulardaten lesen my $form_data; if ($ENV{&#x27;REQUEST_METHOD&#x27;} eq &#x27;POST&#x27;) { read(STDIN, $form_data, $ENV{&#x27;CONTENT_LENGTH&#x27;}); } else { $form_data = $ENV{&#x27;QUERY_STRING&#x27;}; } # Daten parsen my %form_fields; foreach my $pair (split(/&#x26;/, $form_data)) { my ($name, $value) = split(/=/, $pair); $value = uri_unescape($value); $value =~ s/\+/ /g; # + durch Leerzeichen ersetzen $form_fields{$name} = $value; } # HTML-Ausgabe print &#x22;&#x3C;html&#x3E;&#x3C;head&#x3E;&#x3C;title&#x3E;Formulardaten&#x3C;/title&#x3E;&#x3C;/head&#x3E;&#x3C;body&#x3E;\n&#x22;; print &#x22;&#x3C;h1&#x3E;Empfangene Daten:&#x3C;/h1&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;Name: &#x22; . ($form_fields{&#x27;name&#x27;} || &#x27;Nicht angegeben&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;Email: &#x22; . ($form_fields{&#x27;email&#x27;} || &#x27;Nicht angegeben&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;/body&#x3E;&#x3C;/html&#x3E;\n&#x22;;""", 
"cgi2.png", 
"In der nächsten Lektion lernst du Umgebungsvariablen und HTTP-Header kennen.", 
"Zurück zu Lektion 1", 
"Weiter zu Lektion 3", 
2 )

lektion3 = my_class( "Lektion 3: Umgebungsvariablen und HTTP-Header", 
""" CGI-Skripte erhalten viele nützliche Informationen über Umgebungsvariablen. Diese Variablen enthalten Details über die HTTP-Anfrage, den Browser des Benutzers und die Serverumgebung. Wichtige Umgebungsvariablen sind: REQUEST_METHOD (GET, POST, etc.), QUERY_STRING (Parameter bei GET), CONTENT_LENGTH (Größe der POST-Daten), HTTP_USER_AGENT (Browser-Information), REMOTE_ADDR (IP-Adresse des Benutzers), und SERVER_NAME (Name des Servers). HTTP-Header sind wichtig für die Kommunikation zwischen Server und Browser. CGI-Skripte können verschiedene Header senden: Content-Type bestimmt den Medientyp, Location wird für Weiterleitungen verwendet, Set-Cookie setzt Cookies, und Cache-Control steuert das Caching-Verhalten. Header müssen vor dem eigentlichen Inhalt gesendet werden und durch eine Leerzeile getrennt sein. CGI-Skripte können auch eigene HTTP-Statuscodes senden, wie 404 (Not Found) oder 500 (Internal Server Error). In diesem Beispiel siehst du, wie man Umgebungsvariablen ausliest und verschiedene Header verwendet. Das Skript zeigt Browser-Informationen an und demonstriert eine einfache Weiterleitung. """, 
"""#!/usr/bin/perl use strict; use warnings; print &#x22;Content-Type: text/html\n\n&#x22;; print &#x22;&#x3C;html&#x3E;&#x3C;head&#x3E;&#x3C;title&#x3E;CGI Umgebungsvariablen&#x3C;/title&#x3E;&#x3C;/head&#x3E;&#x3C;body&#x3E;\n&#x22;; print &#x22;&#x3C;h1&#x3E;Server-Informationen&#x3C;/h1&#x3E;\n&#x22;; # Wichtige Umgebungsvariablen anzeigen print &#x22;&#x3C;h2&#x3E;HTTP-Anfrage:&#x3C;/h2&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Request Method:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;REQUEST_METHOD&#x27;} || &#x27;Nicht verf&#xFC;gbar&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Query String:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;QUERY_STRING&#x27;} || &#x27;Leer&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Content Length:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;CONTENT_LENGTH&#x27;} || &#x27;0&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;h2&#x3E;Client-Informationen:&#x3C;/h2&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;User Agent:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;HTTP_USER_AGENT&#x27;} || &#x27;Unbekannt&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Remote Address:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;REMOTE_ADDR&#x27;} || &#x27;Unbekannt&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;HTTP Accept:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;HTTP_ACCEPT&#x27;} || &#x27;Nicht verf&#xFC;gbar&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;h2&#x3E;Server-Informationen:&#x3C;/h2&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Server Name:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;SERVER_NAME&#x27;} || &#x27;Unbekannt&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Server Port:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;SERVER_PORT&#x27;} || &#x27;Unbekannt&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; print &#x22;&#x3C;p&#x3E;&#x3C;strong&#x3E;Script Name:&#x3C;/strong&#x3E; &#x22; . ($ENV{&#x27;SCRIPT_NAME&#x27;} || &#x27;Unbekannt&#x27;) . &#x22;&#x3C;/p&#x3E;\n&#x22;; # Beispiel f&#xFC;r Weiterleitung (auskommentiert) # print &#x22;Location: http://www.example.com\n\n&#x22;; print &#x22;&#x3C;/body&#x3E;&#x3C;/html&#x3E;\n&#x22;;""",
"cgi3.png", 
"In der nächsten Lektion lernst du Fehlerbehandlung und Sicherheit bei CGI.", 
"Zurück zu Lektion 2", 
"Weiter zu Lektion 4", 
3 )

lektion4 = my_class( "Lektion 4: Fehlerbehandlung und Sicherheit", 
""" Sicherheit ist bei CGI-Skripten von größter Bedeutung, da sie direkt auf dem Server ausgeführt werden. Ungesicherte CGI-Skripte können zu schwerwiegenden Sicherheitslücken führen. Wichtige Sicherheitsmaßnahmen umfassen: Eingabevalidierung (alle Benutzereingaben prüfen), Ausgabe-Escaping (HTML-Zeichen maskieren), Pfad-Validierung (gefährliche Pfade verhindern), und sichere Dateizugriffe. Cross-Site-Scripting (XSS) ist eine häufige Bedrohung, bei der schädlicher Code in Webseiten eingeschleust wird. CGI-Skripte sollten alle Benutzereingaben filtern und HTML-Zeichen maskieren. SQL-Injection ist bei datenbankgestützten CGI-Skripten ein Problem. Verwende immer Prepared Statements und validiere Eingaben. Fehlerbehandlung ist wichtig für Debugging und Sicherheit. CGI-Skripte sollten Fehler protokollieren, aber keine sensiblen Informationen preisgeben. Verwende 'die' oder 'exit' für kontrollierte Programmbeendigung. Setze angemessene Dateiberechtigungen (meist 755 für CGI-Skripte). In diesem letzten Beispiel zeige ich dir sichere Praktiken: Eingabevalidierung, HTML-Escaping, Fehlerbehandlung und Logging. Das Skript demonstriert, wie man Benutzereingaben sicher verarbeitet. """, 
"""#!/usr/bin/perl use strict; use warnings; use CGI qw(:standard); use HTML::Entities; # F&#xFC;r sicheres HTML-Escaping # Fehler-Logging aktivieren use CGI::Carp qw(fatalsToBrowser warningsToBrowser); warningsToBrowser(1); print header(&#x27;text/html; charset=UTF-8&#x27;); # Sichere Header # Eingabevalidierung sub validate_input { my ($input, $max_length) = @_; return 0 unless defined $input; return 0 if length($input) &#x3E; $max_length; return 0 if $input =~ /&#x3C;script|javascript|vbscript/i; # XSS-Schutz return 1; } # HTML-Ausgabe beginnen print start_html(-title =&#x3E; &#x27;Sicheres CGI-Skript&#x27;, -encoding =&#x3E; &#x27;UTF-8&#x27;); print h1(&#x27;Sichere Datenverarbeitung&#x27;); # Formulardaten sicher verarbeiten if (param()) { my $name = param(&#x27;name&#x27;) || &#x27;&#x27;; my $message = param(&#x27;message&#x27;) || &#x27;&#x27;; # Eingabevalidierung if (validate_input($name, 100) &#x26;&#x26; validate_input($message, 500)) { # HTML-Escaping f&#xFC;r sichere Ausgabe $name = encode_entities($name); $message = encode_entities($message); print h2(&#x27;Empfangene Daten (sicher maskiert):&#x27;); print p(strong(&#x27;Name: &#x27;) . $name); print p(strong(&#x27;Nachricht: &#x27;) . $message); # Daten sicher in Datei speichern (Beispiel) if (open(my $logfile, &#x27;&#x3E;&#x3E;&#x27;, &#x27;/tmp/messages.log&#x27;)) { print $logfile localtime() . &#x22; - Name: $name, Message: $message\n&#x22;; close($logfile); print p(&#x27;Nachricht erfolgreich gespeichert.&#x27;); } else { print p(&#x27;Fehler beim Speichern der Nachricht.&#x27;); } } else { print p(strong(&#x27;Fehler: &#x27;) . &#x27;Ung&#xFC;ltige Eingabedaten erkannt.&#x27;); } } # Sicheres Formular anzeigen print h2(&#x27;Nachricht senden:&#x27;); print start_form(-method =&#x3E; &#x27;POST&#x27;); print p(&#x27;Name: &#x27; . textfield(-name =&#x3E; &#x27;name&#x27;, -maxlength =&#x3E; 100)); print p(&#x27;Nachricht: &#x27; . textarea(-name =&#x3E; &#x27;message&#x27;, -rows =&#x3E; 4, -cols =&#x3E; 50, -maxlength =&#x3E; 500)); print submit(-value =&#x3E; &#x27;Senden&#x27;); print end_form(); print end_html();""",
"cgi4.png", 
"Herzlichen Glückwunsch! Du hast alle CGI-Grundlagen gelernt.", 
"Zurück zu Lektion 3", 
"Kurs abgeschlossen",
 4 )


cgi_class = [lektion1, lektion2, lektion3, lektion4]